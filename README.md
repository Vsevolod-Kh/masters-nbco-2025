# Оптимизация топологии транзитной сети

Это подробное руководство по проекту **Оптимизация топологии транзитной сети**. Ниже описаны все ключевые этапы, модули, отвечающие за каждый шаг, и файлы, которые при этом создаются.

---

## Этап 1 — Загрузка и подготовка данных о городе

**Модуль:** `src/data_download.py`

**Что происходит:**
1. **Загрузка OSM-данных.**  
   Через `osmnx` скачиваются полилинии дорог, контуры зданий, остановки общественного транспорта и точки интереса (POI) внутри границ города.
2. **Сбор кластеров.**  
   Для каждого из пяти слоёв (дороги, остановки, жилые здания, коммерческие здания, POI) выполняется кластеризация:
   - Построение hex‑grid (шестиугольная сетка) по территории города.
   - Вычисление средней плотности объектов в каждом гексе.
   - Применение алгоритма **DBSCAN** (или K-means) для объединения соседних гексов с высокой плотностью в кластеры.
3. **Определение рабочей области.**  
   Из всех кластеров остановок выбирается самый крупный (тот, который покрывает наибольшее число остановок).  
   Вокруг него строится выпуклая оболочка (Convex Hull) с дополнительным буфером (например, 500 м), чтобы задать границы дальнейшей оптимизации.
4. **Первичная аналитика.**  
   Собираются статистики по остановкам и дорогам (количество, среднее расстояние, распределение поездок) и сохраняются в:
   - `results/bus_stops_analysis.json`
   - `results/largest_cluster_boundary.pkl`

---

## Этап 2 — Иерархическая оптимизация остановок

**Модуль:** `src/stops_optimization.py`

**Логика:**
1. **Три уровня важности остановок.**  
   - **Основные узловые остановки (Hubs).** Пересадочные узлы с большим трафиком.  
   - **Региональные остановки (Feeder).** Обслуживают жилые и коммерческие районы.  
   - **Локальные остановки (Local).** Охватывают небольшие группы пассажиров.
2. **Задача минимального покрытия.**  
   С помощью **Google OR-Tools** формируется оптимизационная модель:  
   - Переменные – выбираемые остановки.  
   - Ограничения – каждая точка спроса должна быть в пределах R метров от выбранной остановки.  
   - Целевая функция – минимизировать сумму «штрафов» (количество остановок), одновременно максимизируя покрытие важности.
3. **Сохранение результатов:**
   - `data/opt_stops.pkl` – GeoDataFrame оптимальных остановок.
   - `data/key_stop_idxs.pkl` – индексы основных узлов.
   - `data/ordinary_stop_geoms.pkl` – геометрии всех остальных.

---

## Этап 3 — Генерация синтетических городов

**Модуль:** `src/data_generator.py`

В вашем проекте реализованы следующие методы построения городских графов:

- **_generate_incoming_4nn**  
  Для каждого узла находит 4 ближайших соседей и создаёт ориентированные ребра **к** текущему узлу (входящие связи).

- **_generate_outgoing_4nn**  
  Аналогично, но ребра направляются **от** текущего узла к его 4 ближайшим соседям (исходящие связи).

- **_generate_voronoi**  
  Строит диаграмму Вороного по набору seed-точек; берёт её вершины и рёбра (`ridge_vertices`), фильтрует рёбра по тому, что обе вершины находятся внутри границы города.

- **_generate_4_grid**  
  Создаёт равномерную прямоугольную сетку узлов, соединяя каждый узел с 4 ортогональными соседями.

- **_generate_8_grid**  
  Расширяет 4-grid, добавляя диагональные соединения, так что каждый узел имеет 8 соседей.

Все методы возвращают:
- `nodes_coords: List[Tuple[float, float]]` — координаты узлов.
- `edges_list: List[Tuple[int, int]]` — пары индексов узлов для ребёр.

Далее эти данные используются для создания GeoDataFrame и NetworkX-графа в объектах `CityScenario`.

**Сохраняются:**
- `data/training_cities_<i>.pkl`
- `data/test_cities.pkl`
- `data/routes_raw.pkl`

## Этап 4 — Обучение Neural-BCO

**Модуль:** `src/neural_bco.py`

1. **Архитектура сети**  
   Сеть на основе LSTM: принимает текущую остановку, информацию о соседних остановках и историю маршрута, проходит по скрытым слоям и выдаёт вероятности выбора следующей остановки.

2. **Функция потерь**  
   Составной лосс: MSE между предсказанным и реальным временем поездки + штраф за недостаточное покрытие спроса.

3. **Процесс тренировки**  
   - Данные: синтетические города (`data/training_cities_*.pkl`).  
   - Оптимизатор: AdamW (lr=1e-3, weight_decay=1e-4).  
   - Эпохи: 30 (по умолчанию).  
   - Сохранение лучшей модели: `models/neural_bee_policy.pt`.

4. **Итог**  
   Готовый файл `models/neural_bee_policy.pt` для планировщика маршрутов.

---
## Этап 5 — Планирование маршрутов

**Модуль:** `src/neural_planner.py`

1. **Загрузка** оптимальных остановок (`data/opt_stops.pkl`) и весов сети.
2. **Beam Search**:  
   - Параметр beam_width (обычно 32) управляет шириной поиска.  
   - На каждом шаге генерируются candidate продолжения маршрутов.
3. **Оценка кандидатов** нейросетью:
   - Критерий – взвешенная сумма времени в пути и покрытия населения.
4. **Итоги** записываются в папку `experiments/<run-id>/`:
   - `routes_bco.json`
   - `routes_neural.json`

---

## Этап 6 — MDP-оценка маршрутов

**Модуль:** `src/transit_mdp.py`

Этап предназначен для **детальной симуляции** работы сети:

1. **Модель среды.**  
   - Состояние = (остановка, время).  
   - Действия = вариант пути (ждать, ехать, пересесть).
2. **Генерация пассажиров.**  
   - Поступают по Poisson-процессу с интенсивностью, зависящей от OD-матрицы.
3. **Функция награды.**  
   - Негатив ожидаемого времени в пути (чем меньше, тем лучше).  
   - Штраф за ожидание и лишние пересадки.
4. **Симуляция.**  
   - Исполняется несколько эпизодов (например, 1000) для каждого набора маршрутов.
   - Сохраняются траектории и результаты в `experiments/<run-id>/*.npz`.
5. **Извлечение метрик.**  
   - Среднее время поездки.  
   - Среднее количество пересадок.  
   - Покрытие спроса (% пассажиров доставлено).

---

## Оркестратор конвейера

**Модуль:** `src/training_pipeline.py`  
**Кратко:**
- Читает параметр `--step` (0–6) для частичного запуска; по умолчанию выполняет все этапы последовательно.
- Автоматически создаёт run-id и папку `experiments/<run-id>/`.
- Логирует начало и конец каждого шага.

---

## Входные файлы перед стартом

1. **`data/district_population.csv`**  
2. **5 GeoJSON-слоёв** в `data/clusters/`:  
   - `roads_cluster.geojson`  
   - `bus_stops_cluster.geojson`  
   - `residential_buildings_cluster.geojson`  
   - `commercial_buildings_cluster.geojson`  
   - `poi_cluster.geojson`  
3. *(опционально)* pre-trained веса в `models/`:  
   - `neural_bee_policy.pt`  
   - `neural_planner_best.pth`  

Остальные файлы генерируются автоматически каждым модулем.

---

## Окружение и зависимости

```bash
pip install -r requirements.txt
# Требуются GDAL/PROJ/GEOS для geopandas и osmnx
# Выберите whl для torch под вашу систему (CPU/GPU).
```
